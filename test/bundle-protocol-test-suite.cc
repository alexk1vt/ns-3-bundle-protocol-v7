/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 *  Copyright (c) 2013 University of New Brunswick
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Dizhi Zhou <dizhi.zhou@gmail.com>
 */

#include <string>
#include <fstream>
#include <tgmath.h>
#include "ns3/bp-endpoint-id.h"
#include "ns3/bundle-protocol.h"
#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/internet-module.h"
#include "ns3/network-module.h"
#include "ns3/bp-endpoint-id.h"
#include "ns3/bundle-protocol.h"
#include "ns3/bp-static-routing-protocol.h"
#include "ns3/bundle-protocol-helper.h"
#include "ns3/bundle-protocol-container.h"
#include "ns3/test.h"

NS_LOG_COMPONENT_DEFINE ("BundleProtocolTestSuite");

using namespace ns3;

class BundleProtocolTestCase : public TestCase
{
public:
  BundleProtocolTestCase (uint32_t sentBundleSize, uint32_t bundleSize, uint32_t segmentSize, std::string claType);
  virtual ~BundleProtocolTestCase ();

private:
  virtual void DoRun (void);
  void Send (Ptr<BundleProtocol> sender, uint32_t size, BpEndpointId src, BpEndpointId dst);
  void Receive (Ptr<BundleProtocol> receiver, BpEndpointId eid);
  void Register (Ptr<BundleProtocol> node, BpEndpointId eid, InetSocketAddress l4Address);

private:
  uint32_t m_sentBundleSize;   
  uint32_t m_receivedBundleSize;
  uint32_t m_receivedBundleNumber;
  uint32_t m_bundleSize;
  uint32_t m_tcpSegmentSize;
  std::string m_claType;
};

static class BundleProtocolTestSuite : public TestSuite
{
public:
  BundleProtocolTestSuite ()
  : TestSuite ("bundle-protocol", UNIT)
    {
      NS_LOG_INFO ("creating BundleProtocolTestSuite");

      AddTestCase (new BundleProtocolTestCase (1000, 400, 512, "Tcp"), TestCase::QUICK);
      AddTestCase (new BundleProtocolTestCase (1000, 512, 512, "Tcp"), TestCase::QUICK);
      AddTestCase (new BundleProtocolTestCase (1000, 1000, 512, "Tcp"), TestCase::QUICK);
    }

} g_bundleProtocolTestSuite;

BundleProtocolTestCase::BundleProtocolTestCase (uint32_t sentBundleSize, uint32_t bundleSize, uint32_t segmentSize, 
    std::string claType)
  : TestCase ("Test that all the bundles generated by a sender bundle node are correctly received by a receiver bundle node"),
    m_sentBundleSize (sentBundleSize),
    m_receivedBundleSize (0),
    m_receivedBundleNumber (0),
    m_bundleSize (bundleSize),
    m_tcpSegmentSize (segmentSize),
    m_claType (claType)
{
}

BundleProtocolTestCase::~BundleProtocolTestCase ()
{
}

void
BundleProtocolTestCase::DoRun (void)
{
  ns3::PacketMetadata::Enable ();

  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("500Kbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("5ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);

  InternetStackHelper internet;
  internet.Install (nodes);

  Ipv4AddressHelper ipv4;
  ipv4.SetBase ("10.1.1.0", "255.255.255.0");
  Ipv4InterfaceContainer i = ipv4.Assign (devices);

  std::ostringstream l4type;
  l4type << m_claType;
  Config::SetDefault ("ns3::BundleProtocol::L4Type", StringValue (l4type.str ()));
  Config::SetDefault ("ns3::BundleProtocol::BundleSize", UintegerValue (m_bundleSize)); 
  Config::SetDefault ("ns3::TcpSocket::SegmentSize", UintegerValue (m_tcpSegmentSize));

  // build endpoint ids
  BpEndpointId eidSender ("dtn", "node0");
  BpEndpointId eidRecv ("dtn", "node1");

  // get node L4 addresses
  InetSocketAddress Node0Addr (i.GetAddress (0), 9);
  InetSocketAddress Node1Addr (i.GetAddress (1), 9);

  // set bundle static routing
  Ptr<BpStaticRoutingProtocol> route = CreateObject<BpStaticRoutingProtocol> ();
  //route->AddRoute (eidSender, InetSocketAddress (i.GetAddress (0), 9));
  //route->AddRoute (eidRecv, InetSocketAddress (i.GetAddress (1), 9));

  // sender  
  BundleProtocolHelper bpSenderHelper;
  bpSenderHelper.SetRoutingProtocol (route);
  bpSenderHelper.SetBpEndpointId (eidSender);
  BundleProtocolContainer bpSenders = bpSenderHelper.Install (nodes.Get (0));
  bpSenders.Start (Seconds (0.1));
  bpSenders.Stop (Seconds (1.0));

  // receiver
  BundleProtocolHelper bpReceiverHelper;
  bpReceiverHelper.SetRoutingProtocol (route);
  bpReceiverHelper.SetBpEndpointId (eidRecv);
  BundleProtocolContainer bpReceivers = bpReceiverHelper.Install (nodes.Get (1));
  bpReceivers.Start (Seconds (0.0));
  bpReceivers.Stop (Seconds (1.0));

  char data[] = "The Senate of the United States shall be composed of two Senators from each State, "
                "chosen by the Legislature thereof, for six Years; and each Senator shall have one Vote."
                "Immediately after they shall be assembled in Consequence of the first Election, they shall"
                " be divided as equally as may be into three Classes. The Seats of the Senators of the"
                " first Class shall be vacated at the Expiration of the second Year, of the second Class at"
                " the Expiration of the fourth Year, and of the third Class at the Expiration of the sixth"
                " Year, so that one third may be chosen every second Year; and if Vacancies happen by "
                "Resignation, or otherwise, during the Recess of the Legislature of any State, the Executive"
                " thereof may make temporary Appointments until the next Meeting of the Legislature, which"
                " shall then fill such Vacancies. No Person shall be a Senator who shall not have attained"
                " to the Age of thirty Years, and been nine Years a Citizen of the United States, and who"
                " shall not, when elected, be an Inhabitant of that State for which he shall be chosen."
                "The Vice President of the United States shall be President of the Senate, but shall have "
                "no Vote, unless they be equally divided.  The Senate shall chuse their other Officers, "
                "and also a President pro tempore, in the Absence of the Vice President, or when he shall"
                " exercise the Office of President of the United States. The Senate shall have the sole "
                "Power to try all Impeachments. When sitting for that Purpose, they shall be on Oath or"
                " Affirmation. When the President of the United States is tried, the Chief Justice shall"
                " preside: And no Person shall be convicted without the Concurrence of two thirds of the "
                "Members present. Judgment in Cases of Impeachment shall not extend further than to removal"
                " from Office, and disqualification to hold and enjoy any Office of honor, Trust or Profit"
                " under the United States: but the Party convicted shall nevertheless be liable and subject"
                " to Indictment, Trial, Judgment and Punishment, according to Law.";

  // register external nodes with each node
  Simulator::Schedule (Seconds (0.1), &BundleProtocolTestCase::Register, this, bpSenders.Get (0), eidRecv, Node1Addr);
  Simulator::Schedule (Seconds (0.1), &BundleProtocolTestCase::Register, this, bpReceivers.Get (0), eidSender, Node0Addr);

  Simulator::Schedule (Seconds (0.2), &BundleProtocolTestCase::Send, this, bpSenders.Get (0), 
                       m_sentBundleSize, eidSender, eidRecv);
  Simulator::Schedule (Seconds (0.8), &BundleProtocolTestCase::Receive, this, bpReceivers.Get (0), 
                       eidRecv);

  Simulator::Stop (Seconds (1.0));
  Simulator::Run ();
  Simulator::Destroy ();

  double received = m_receivedBundleSize;
  double bundleSize = m_bundleSize;
  uint32_t num = ceil (received/bundleSize);
  NS_TEST_EXPECT_MSG_EQ (m_receivedBundleSize, m_sentBundleSize, "All bundles are received at the receiver");
  NS_TEST_EXPECT_MSG_EQ (m_receivedBundleNumber, num , "Correct number of bundles are received at the receiver");

}


void 
BundleProtocolTestCase::Send (Ptr<BundleProtocol> sender, uint32_t size, BpEndpointId src, BpEndpointId dst)
{
  //Ptr<Packet> packet = Create<Packet> (size);
  //sender->Send (packet, src, dst);
  char* data = new char[size];
  sender->Send_data (reinterpret_cast<const uint8_t*>(data), size, src, dst);
}

void 
BundleProtocolTestCase::Receive (Ptr<BundleProtocol> receiver, BpEndpointId eid)
{
  //Ptr<Packet> p = receiver->Receive (eid);
  std::vector<uint8_t> data = receiver->Receive_data (eid);
  //while (p != NULL)
  while (!data.empty())
    {
      //m_receivedBundleSize += p->GetSize ();
      uint32_t size = data.size();
      m_receivedBundleSize += size;
      char* buffer = new char[size+1];
      std::copy(data.begin(), data.end(), buffer);
      buffer[size] = '\0';
      m_receivedBundleNumber++;

      delete [] buffer;
      data = receiver->Receive_data (eid);
    }
}

void
BundleProtocolTestCase::Register (Ptr<BundleProtocol> node, BpEndpointId eid, InetSocketAddress l4Address)
{
    std::cout << Simulator::Now ().GetMilliSeconds () << " Registering external node " << eid.Uri () << std::endl;
    node->ExternalRegisterTcp (eid, 0, true, l4Address);
}